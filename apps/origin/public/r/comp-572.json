{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "files": [
    {
      "content": "\"use client\";\n\nimport {\n  expandAllFeature,\n  hotkeysCoreFeature,\n  searchFeature,\n  selectionFeature,\n  syncDataLoaderFeature,\n  type TreeState,\n} from \"@headless-tree/core\";\nimport { useTree } from \"@headless-tree/react\";\nimport {\n  CircleXIcon,\n  FilterIcon,\n  FolderIcon,\n  FolderOpenIcon,\n} from \"lucide-react\";\nimport type React from \"react\";\nimport { useEffect, useRef, useState } from \"react\";\n\nimport { Input } from \"@/registry/default/ui/input\";\nimport { Tree, TreeItem, TreeItemLabel } from \"@/registry/default/ui/tree\";\n\ninterface Item {\n  name: string;\n  children?: string[];\n}\n\nconst items: Record<string, Item> = {\n  apis: { name: \"APIs\" },\n  backend: { children: [\"apis\", \"infrastructure\"], name: \"Backend\" },\n  company: {\n    children: [\"engineering\", \"marketing\", \"operations\"],\n    name: \"Company\",\n  },\n  components: { name: \"Components\" },\n  content: { name: \"Content\" },\n  \"design-system\": {\n    children: [\"components\", \"tokens\", \"guidelines\"],\n    name: \"Design System\",\n  },\n  engineering: {\n    children: [\"frontend\", \"backend\", \"platform-team\"],\n    name: \"Engineering\",\n  },\n  finance: { name: \"Finance\" },\n  frontend: { children: [\"design-system\", \"web-platform\"], name: \"Frontend\" },\n  guidelines: { name: \"Guidelines\" },\n  hr: { name: \"HR\" },\n  infrastructure: { name: \"Infrastructure\" },\n  marketing: { children: [\"content\", \"seo\"], name: \"Marketing\" },\n  operations: { children: [\"hr\", \"finance\"], name: \"Operations\" },\n  \"platform-team\": { name: \"Platform Team\" },\n  seo: { name: \"SEO\" },\n  tokens: { name: \"Tokens\" },\n  \"web-platform\": { name: \"Web Platform\" },\n};\n\nconst indent = 20;\n\nexport default function Component() {\n  // Store the initial expanded items to reset when search is cleared\n  const initialExpandedItems = [\"engineering\", \"frontend\", \"design-system\"];\n  const [state, setState] = useState<Partial<TreeState<Item>>>({});\n  const [searchValue, setSearchValue] = useState(\"\");\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const tree = useTree<Item>({\n    dataLoader: {\n      getChildren: (itemId) => items[itemId].children ?? [],\n      getItem: (itemId) => items[itemId],\n    },\n    features: [\n      syncDataLoaderFeature,\n      hotkeysCoreFeature,\n      selectionFeature,\n      searchFeature,\n      expandAllFeature,\n    ],\n    getItemName: (item) => item.getItemData().name,\n    indent,\n    initialState: {\n      expandedItems: initialExpandedItems,\n    },\n    isItemFolder: (item) => (item.getItemData()?.children?.length ?? 0) > 0,\n    rootItemId: \"company\",\n    setState,\n    state,\n  });\n\n  // Handle clearing the search\n  const handleClearSearch = () => {\n    setSearchValue(\"\");\n\n    // Manually trigger the tree's search onChange with an empty value\n    // to ensure item.isMatchingSearch() is correctly updated.\n    const searchProps = tree.getSearchInputElementProps();\n    if (searchProps.onChange) {\n      const syntheticEvent = {\n        target: { value: \"\" },\n      } as React.ChangeEvent<HTMLInputElement>; // Cast to the expected event type\n      searchProps.onChange(syntheticEvent);\n    }\n\n    // Reset tree state to initial expanded items\n    setState((prevState) => ({\n      ...prevState,\n      expandedItems: initialExpandedItems,\n    }));\n\n    // Clear custom filtered items\n    setFilteredItems([]);\n\n    if (inputRef.current) {\n      inputRef.current.focus();\n      // Also clear the internal search input\n      inputRef.current.value = \"\";\n    }\n  };\n\n  // Keep track of filtered items separately from the tree's internal search state\n  const [filteredItems, setFilteredItems] = useState<string[]>([]);\n\n  // This function determines if an item should be visible based on our custom filtering\n  const shouldShowItem = (itemId: string) => {\n    if (!searchValue || searchValue.length === 0) return true;\n    return filteredItems.includes(itemId);\n  };\n\n  // Update filtered items when search value changes\n  useEffect(() => {\n    if (!searchValue || searchValue.length === 0) {\n      setFilteredItems([]);\n      return;\n    }\n\n    // Get all items\n    const allItems = tree.getItems();\n\n    // First, find direct matches\n    const directMatches = allItems\n      .filter((item) => {\n        const name = item.getItemName().toLowerCase();\n        return name.includes(searchValue.toLowerCase());\n      })\n      .map((item) => item.getId());\n\n    // Then, find all parent IDs of matching items\n    const parentIds = new Set<string>();\n    for (const matchId of directMatches) {\n      let item = tree.getItems().find((i) => i.getId() === matchId);\n\n      while (item?.getParent?.()) {\n        const parent = item.getParent();\n        if (parent) {\n          parentIds.add(parent.getId());\n          item = parent;\n        } else {\n          break;\n        }\n      }\n    }\n\n    // Find all children of matching items\n    const childrenIds = new Set<string>();\n    for (const matchId of directMatches) {\n      const item = tree.getItems().find((i) => i.getId() === matchId);\n\n      if (item?.isFolder()) {\n        const getDescendants = (itemId: string) => {\n          const children = items[itemId]?.children || [];\n\n          for (const childId of children) {\n            childrenIds.add(childId);\n\n            if (items[childId]?.children?.length) {\n              getDescendants(childId);\n            }\n          }\n        };\n\n        getDescendants(item.getId());\n      }\n    }\n\n    // Combine direct matches, parents, and children\n    setFilteredItems([\n      ...directMatches,\n      ...Array.from(parentIds),\n      ...Array.from(childrenIds),\n    ]);\n\n    // Keep all folders expanded during search to ensure all matches are visible\n    // Store current expanded state first\n    const currentExpandedItems = tree.getState().expandedItems || [];\n\n    // Get all folder IDs that need to be expanded to show matches\n    const folderIdsToExpand = allItems\n      .filter((item) => item.isFolder())\n      .map((item) => item.getId());\n\n    // Update expanded items in the tree state\n    setState((prevState) => ({\n      ...prevState,\n      expandedItems: [\n        ...new Set([...currentExpandedItems, ...folderIdsToExpand]),\n      ],\n    }));\n  }, [searchValue, tree]);\n\n  return (\n    <div className=\"flex h-full flex-col gap-2 *:nth-2:grow\">\n      <div className=\"relative\">\n        <Input\n          className=\"peer ps-9\"\n          onBlur={(e) => {\n            // Prevent default blur behavior\n            e.preventDefault();\n\n            // Re-apply the search to ensure it stays active\n            if (searchValue && searchValue.length > 0) {\n              const searchProps = tree.getSearchInputElementProps();\n              if (searchProps.onChange) {\n                const syntheticEvent = {\n                  target: { value: searchValue },\n                } as React.ChangeEvent<HTMLInputElement>;\n                searchProps.onChange(syntheticEvent);\n              }\n            }\n          }}\n          onChange={(e) => {\n            const value = e.target.value;\n            setSearchValue(value);\n\n            // Apply the search to the tree's internal state as well\n            const searchProps = tree.getSearchInputElementProps();\n            if (searchProps.onChange) {\n              searchProps.onChange(e);\n            }\n\n            if (value.length > 0) {\n              // If input has at least one character, expand all items\n              tree.expandAll();\n            } else {\n              // If input is cleared, reset to initial expanded state\n              setState((prevState) => ({\n                ...prevState,\n                expandedItems: initialExpandedItems,\n              }));\n              setFilteredItems([]);\n            }\n          }}\n          placeholder=\"Filter items...\"\n          // Prevent the internal search from being cleared on blur\n          ref={inputRef}\n          type=\"search\"\n          value={searchValue}\n        />\n        <div className=\"pointer-events-none absolute inset-y-0 start-0 flex items-center justify-center ps-3 text-muted-foreground/80 peer-disabled:opacity-50\">\n          <FilterIcon aria-hidden=\"true\" className=\"size-4\" />\n        </div>\n        {searchValue && (\n          <button\n            aria-label=\"Clear search\"\n            className=\"absolute inset-y-0 end-0 flex h-full w-9 items-center justify-center rounded-e-md text-muted-foreground/80 outline-none transition-[color,box-shadow] hover:text-foreground focus:z-10 focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50\"\n            onClick={handleClearSearch}\n            type=\"button\"\n          >\n            <CircleXIcon aria-hidden=\"true\" className=\"size-4\" />\n          </button>\n        )}\n      </div>\n\n      <Tree indent={indent} tree={tree}>\n        {searchValue && filteredItems.length === 0 ? (\n          <p className=\"px-3 py-4 text-center text-sm\">\n            No items found for \"{searchValue}\"\n          </p>\n        ) : (\n          tree.getItems().map((item) => {\n            const isVisible = shouldShowItem(item.getId());\n\n            return (\n              <TreeItem\n                className=\"data-[visible=false]:hidden\"\n                data-visible={isVisible || !searchValue}\n                item={item}\n                key={item.getId()}\n              >\n                <TreeItemLabel>\n                  <span className=\"flex items-center gap-2\">\n                    {item.isFolder() &&\n                      (item.isExpanded() ? (\n                        <FolderOpenIcon className=\"pointer-events-none size-4 text-muted-foreground\" />\n                      ) : (\n                        <FolderIcon className=\"pointer-events-none size-4 text-muted-foreground\" />\n                      ))}\n                    {item.getItemName()}\n                  </span>\n                </TreeItemLabel>\n              </TreeItem>\n            );\n          })\n        )}\n      </Tree>\n\n      <p\n        aria-live=\"polite\"\n        className=\"mt-2 text-muted-foreground text-xs\"\n        role=\"region\"\n      >\n        Tree with filtering âˆ™{\" \"}\n        <a\n          className=\"underline hover:text-foreground\"\n          href=\"https://headless-tree.lukasbach.com\"\n          rel=\"noopener noreferrer\"\n          target=\"_blank\"\n        >\n          API\n        </a>\n      </p>\n    </div>\n  );\n}\n",
      "path": "registry/default/components/comp-572.tsx",
      "type": "registry:component"
    }
  ],
  "meta": {
    "tags": ["tree", "filter", "search"]
  },
  "name": "comp-572",
  "registryDependencies": [
    "https://coss.com/origin/r/tree.json",
    "https://coss.com/origin/r/input.json"
  ],
  "type": "registry:component"
}
